Django: Getting Started
by Reindert-Jan Ekker
Django is the most popular and mature Python web development framework. It lets you build better web apps quicker, and with less code. In this course, you will learn how to build your first web application with Django and Python.

Table of contents
Description
Transcript
Exercise files
Discussion
Learning Check
Related Courses

Course Overview
Hi, everyone. My name is Reindert‑Jan Ekker, and welcome to my course, Django: Getting Started. I'm a long‑time developer and educator, and in this course, I will teach you about creating web applications with Django, the web framework for perfectionists. Django is the most popular web development framework for Python, and it's awesome to work with. In this course, we're going to build a web application with Django, and along the way, you will learn about all its major components. We will cover templates and URL mappings, Django model classes, and the admin site, using HTML forms for user input and much more. By the end of this course, you will have a firm understanding of all of these and how they work together, and you'll be able to create your first website with Django. Before beginning the course, you should be familiar with Python and the basics of HTML. I hope you'll join me on this journey to learn web development with Python and Django, with the Django: Getting Started course at Pluralsight.

Starting a Django Project
Introducing Django
Hi, this is Reindert‑Jan Ekker, and welcome to this course about getting started with Django. In this module, I'll give you a short introduction of Django, and I'll also go over the prerequisites for this course: what should you already know to be able to follow the course, which software needs to be installed in your system, etc. After that, I'll show you a demo of the project we'll build, and then we'll start our first Django project, and we're going to explore the files that it's made up of. We'll run the project and look at it in a browser. We won't be creating our own content yet, that's for the next module. Django is a framework for writing web applications in Python. It focuses on being very productive without writing lots of code, and on making the code you have to write as clean and elegant as possible. By the way, just in case you were wondering, Django was named after Django Reinhardt, the famous jazz guitar player, so it's got nothing to do with the Tarantino movie. So why would you want to learn Django? Well, Django comes with batteries included. There's a huge standard library with lots of functionalities to solve just about any problem. And what's more, there are lots and lots of Django‑specific packages to make your life as a web developer easier. All of this makes it possible to be very productive with Django right from the start. Here's some of the most important features that come installed with Django. There's a powerful object‑relational mapping API, which allows you to write pure Python classes that represent your database tables. This means you won't have to write SQL queries to interact with your database. When you've written the model classes that represent your data, Django can generate an admin interface. This is a web‑based user interface for editing content, and it's generated automatically by Django. This very powerful feature can really speed up your development cycle. Django also comes with a small but powerful template language for generating your web pages, and a beautiful way to configure the URLs for your site. It will also let you handle HTML forms with a minimum of code, or often without any code at all. And in case there's something you're missing in the temperate language or the standard form classes or any other part of Django, there is a huge amount of third‑party packages that will probably offer what you need, and that's just the tip of the iceberg. Some other features that Django offers out‑of‑the‑box are user authentication, HTTP session handling, a powerful high performance caching system, and some very nice internationalization supports.

Prerequisites
So now you know why you might want to learn Django, and here's a short of your things that you should already know before watching this course. First of all, Django is a Python framework, so you should be familiar with Python. At the very least, watch the introductory Python course and write some simple programs. Although Django does use some advanced concepts, we're going to stick to the basics. So a general understanding of the core language will be enough to get you started. You should also know how to use pip to install packages. If you don't know these things, please watch my course on Pluralsight called Managing Python Packages and Virtual Environments. You should also know the basics of web development, and that means you should at least know how to write a simple HTML page. It may be helpful if you also know a bit about CSS styling, although you should be able to follow everything even if you don't. We're also going to touch on the HTTP protocol a bit, which is the protocol that enables a browser to ask a server for a web page. But if you don't know about HTTP, don't worry, it's not hard at all, and I'll explain everything you need to know. Finally, it's also important that you know the basics of databases. We will use a database to store our application's data, and we're going to let Django create and modify our database tables. There's no need to write any actual SQL statements, but you should be familiar with the concept of tables, rows, or what an insert or update means. So what do you need to have installed on your system to use Django? Both Python and Django are cross‑platform, which means you can work along with this course regardless of your operating system, be it Linux, macOS, or Windows. In this course, I will be working with Django 3, which supports Python 3.6, 3.7, or 3.8. So if you're running an older version of Python, be sure to update. Then there's something that I think no developer should do without, and that's an editor with Python support. For this course, I will be using the Community Edition of PyCharm, which is a very full‑featured piece of software with a lot of features for Python developments. But there are many, many other editors, and you should be able to follow this course if you use another editor. I will tell you when you will need to take different steps than I do.

Project Preview
Let me give you a preview of the project we're going to build in this course. It's a tiny meeting planner web application. What you see here is the home page. It says, Welcome to the Meeting Planner, and it shows an overview of all the meetings that already have been planned. It's this little list here. There's a form to add a new meeting where I can enter the title for a new meeting and the date and time, as well as select a room. And if I click OK, the new meeting shows up here in the Meetings lists. We can also click on a meeting and see its details. And let's go back. Here's the Rooms list, which shows all the rooms that we have in our database. So this application includes a database with all the data, and you can also see that all the pages are styled, even though it's kind of minimalist. And one cool thing is that every Django application comes with a built‑in admin interface. So I can log in here as an administrator, and here we see the default Django administration interface that allows us to manage our room and meetings objects. For example, here, if I go into Rooms, I can inspect, edit, add, and delete the rooms that are available in my database. And a similar thing goes for all the other data, like all the meetings in the database. So this is what we'll be working towards during this course.

Installing Django
Now let's really get started. We're going to start a PyCharm project, install Django, create a Django project, run that, and inspect the results in a browser. For this course, I will use Community Edition of PyCharm as my editor. You should be able to follow this course if you use another editor. I will tell you when you will need to take different steps than I do. In my case, I start by creating a new project, and this takes me to the New Project screen. As the location for my project, I choose django_getting_started under PyCharmProjects. PyCharm will create this folder for me, so if you work with another editor, you might need to create your own folder for your project. PyCharm also automatically creates a virtual environment for my project. If I click on the triangle here, you see that it will create a virtual environment for me in my .virtualenvs folder, and the name of the environment is the same as the name of the projects. It's based on my latest installed Python version, which is 3.6. Now, if you're not using PyCharm, you probably want to create your own virtual environment, and if you don't know how to do that, please take a moment to watch the module about that in my course, Managing Python Packages and Virtual Environments. Anyway, I like the default settings, so I'm going to click Create. On some systems, creating a PyCharm project takes a couple of minutes, so you might need to wait a little bit here. When it's done, you can click Close on the Tip of the Day, because we don't need that. Now this is the empty project PyCharm has just created for us, but before we can start writing code, I need to install Django. To do so, I want to start a terminal in an active virtual environment. Now, the course I mentioned before will show you how to do that in general, but PyCharm actually has a nice shortcut for us. If I click Terminal at the bottom here, it starts a terminal session, and as you can see at the start of the line here, we are already inside our active environments. That means that to install Django, I only have to say python ‑m pip install django. And this downloads and installs Django, as well as its dependencies. Now, instead of starting your own project and writing the code yourself, you can also download the demo code from Pluralsight, and the project is also available on GitHub. So you can also clone the GitHub project, which is available at the location shown here. In that case, you will always have to create your own virtual environment and install Django, and I cannot do that for you. If you download the demo code, the project will look slightly different. Let me show you. So if you download the source code and you open this folder here, django_getting_started, there are two extra files, which we didn't create ourselves, they're on Git, and they're called .gitignore, which is a thing specific to Git projects, and the other one is requirements.txt, and that lists the packages that this project depends on. If you download the the demo code, you will get these files, but the project will also work fine without them.

Starting a Project
Now that we have Django installed, we can start a Django project, which is a different thing from a PyCharm project. So PyCharm is the editor and Django is the Python framework that we will write our code for. We start a Django project by running a script called Django admin. Now this Django admin script can do many things, but the most common thing we use it for is to create a new Django project by saying startproject followed by the name of the project. For this course, I'm going to call my demo project meeting planner. And now when I press Enter, this will create a new folder with exactly that name. The Django admin script itself doesn't give any output, but the new folder should show up in PyCharm, but sometimes it doesn't, and in that case, you can right‑click on the project and say Reload from Disk. And now we see our new folder meeting_planner. We can click on the triangle here to see what's in the folder, and there is a file here called manage.py. This is a script we will use from now on to run Django commands. Let's try it out right now, but to do so, we need to move into the meeting_planner folder where the script is located. We do that by typing cd meeting_planner and you can see the text here changed to show that we're now in this folder. We can now run the project by saying python manage.py runserver. This runs the Django development web server and it prints some information for us. The red text here is a warning that we will address in a later module. We can ignore it for now. The server also shows us a URL, this is where it actually hosts our web application. Now, when I click this URL, a browser opens, and this is what we get to see the install worked successfully. Congratulations! Of course, this is just a simple demo page for an empty web app, and we're going to add our own pages soon, but for now, let's do some investigation. First of all, we see that the actual address is 127.0.0.1, which is a special IP address reserved for your local machine, which means that I am connected to my computer, but if you type this in, you will connect to your own computer. And then it has a column, followed by the port number 8000 and that's the port that the Django server is listening on. So if you type this address into your browser, it will connect to your running Django web server. Now for a moment, let's just stop the server. I'm going back to the terminal here, and in the terminal, I'm going to press Ctrl+C, this stops the server and now you see the directory we're in, which means you can now enter a new terminal command, which is not what we're going to do. I want to go back to the browser for a moment, and if I refresh the page now, I get the message unable to connect, and this is because right now my server isn't running, so there is no process listening to Port 8000 at my local address. Now let's take a moment and take a better look at what's in our Django projects. First of all, there is a new file here called db.sqlite3, and that's a database file that Django created automatically when we ran the server. At the moment, it contains no data at all, and we'll learn more about it in the next module. Then there is a second meeting_planner folder in here, and you can basically think of this folder as the core project folder. If you look inside, we see that it contains a file settings.py, and this is basically where our project is defined. If you double‑click it, we see the settings for the meeting planner project. Throughout the course, we'll use this file to configure our projects. There is also other files here, urls.py, which is where we're going to put the code that assigns URLs to the pages that we will create, and there are files asgi and wsgi.py. Those are used when you want to deploy your projects to a production server. Finally, there is a file, init.py, which is empty, and it's only there to mark this folder as a Python package. So this is what the Django admin start project command created for us. It mainly comes out to this file, settings.py and urls.py, those are the backbone of our web app. And one folder higher, there is the manage.py script and the sqlite database, which was not created by Django admin, but by running the server. The folder structure of this project can be a little confusing at first, so let me just go over each of the folders again. The top level folder django_getting_started has been created by PyCharm and it contains my gitignore and requirements files. Inside there is the Django project folder called meeting_planner, and that has a second folder inside it with the same name and that contains my Django project settings. This structure will slowly become more and more clear as we write code and see how to work with those folders.

Review
Let's go over the main things we've just learned. We started by installing Django by calling pip install django. It's best practice to always install things inside a virtual environment, and things are no different with Django. If you use PyCharm, it will actually create an environment for you automatically when you set up a new project. Next, we created a Django project. You do this with the django‑admin script that comes with your Django installation. You can simply call it like this, django‑admin.py, startproject, and then the name of the project. Note that the django‑admin script is installed inside the virtual environment, so make sure that you're inside your active virtual environment before you try to run this. To run a Django project, you move into the project directory with the cd command and then run the manage.py script with the runserver command. This will start the built‑in Django development server. It's a fast and lightweight web server that will reload the changes in your code automatically, which is nice because it really speeds up development. By the way, you can stop the server by pressing Ctrl+C in the terminal window. Now one thing I cannot repeat enough is that you should never, ever do this in production. The Django production server is not secure or performant enough for a real‑world deployment environment, so you should never do that. Finally, if you want to work along with this course, here's the URL to the GitHub repository that contains all of the source code. Or if you prefer, you can download the code for each module from Pluralsight. And that's it. We've started this course by installing Django, setting up a Django project, running that, and exploring what the project looks like. Let's move on to the next module in which we'll write some code of our own and create our first webpage with Django.

Creating a Simple Web Page
Creating a Django App
Hi, I'm Reindert‑Jan Ekker, and in this module we'll create our first web page with Django. Our goal in this module will be to add our own page to the Django projects. To get to that point, we need to take several steps. First, we'll create a component called a Django app, which will contain the code we'll write, and our code will take the form of a so‑called view function. Then we will add some code to assign a URL to this view function. After doing that, we will run the project and view our new page. We'll also take some time to make sure that you understand how all these components work together to create a Django web page, and I'll go over some of the common problems and pitfalls that you might run into. Let's dive straight in and create our first web page with Django. To do so, we create a new component called a Django app. In there, we will define a so‑called view function for our page, assign a URL to it, and then we can run the project and view the page. Here we are back in our project, and I want to create my first web page. In Django, the best practice is to group your code together into so‑called apps. A Django app is just a folder containing Python files, so it doesn't have anything to do with a mobile phone app or similar things. I can create a new app by running a command in the terminal. So I'm starting the terminal, and I check the text here. It says I'm currently in the top‑level folder in my projects, django_getting_started, but the manage.py script is one level deeper in meeting_planner. Now please check for yourself what the current directory is in your terminal. If you're already in the meeting_planner directory, you're fine. Also, if your server is still running, remember you can press Ctrl+C to stop it. But in my case, since I'm not in the right folder, I need to say cd meeting_planner to move into the correct location. Now, in case you get confused or the terminal gets messed up, you can always press the little x here to stop the terminal and then start a new terminal. This will always start in the top‑level project folder, so again, I have to start by moving into the correct location. I can now run the manage.py script as follows, python manage.py, and I give it the command startapp, followed by the name of the app I want to create. In this case, I'm adding an app that will contain general pages for my website, like the welcome page, a contact page, an about page, and that's why I'm calling the app website. Now, to run it I press Enter, and just like the startproject in the previous demo, this command creates a new folder with the name we just specified. So there's a folder website now. Let's check the content. So, manage.py created a number of files for us. At the moment, we'll focus on views.py, and I'm going to remove everything else but the __init_.py file, we'll talk about what these files do later. For now, I'm going to remove all these except views.py and __init_.py. Even the migrations folder can go. So we're left with these two. The __init_.py file is empty. It just marks this folder as a Python package. The views.py file is where I'm going to write my code. We see an import statement and the text, Create your views here. This is where we'll write the actual code for our web page. But first I need to make sure that the code I write here will be seen and run by Django. To do that, I need to open settings.py in the meeting_planner folder. Remember that this folder is sort of the core folder for our project, and it contains the project settings.py file. There's lots of settings here, and I'm not going to explain all of that, but if we scroll down a bit, we find a setting called INSTALLED_APPS. To make the code from our new app available in Django, we need to add it to the list here. Good, now our app is installed as part of our project.

Adding a Page
Let's close settings.py and go back to views.py. We're going to add our own view here. The view is a Django component that handles a request for a web page. In our case, we will write a function called welcome, like this. So this is a normal Python function. It has an argument request, which we currently don't use, and in return, something called an HttpResponse with the string, Welcome to the Meeting Planner! We call this a view function, and its purpose is to handle an HttpRequest for the welcome page of our site. In other words, when a user visits that welcome page, this function will be called, and it will send the string, Welcome to the Meeting Planner! back so it can be shown in the browser. By the way, I shouldn't forget to import the HttpResponse class at the top of the file to make this work. So now I have a view function. But how do I visit this page for my browser? We need to assign a URL to our view so that we can actually visit it. Let's open urls.py, which is in the same folder as the settings module. So here there's a lot of documentation with instructions how to write URL mappings. But mainly there's this list called urlpatterns, and in this list, we can put all our URL mappings. There's already one mapping here for admin, and we'll talk a little bit more about that in the next module. Now I'm going to start by importing the view we just wrote like this. From website.views, import welcome. And now I can add a line to the urlpatterns list by calling the function path with two arguments. Here the first argument specifies the URL, and the second argument is the actual view function. What this means is that when a user wants to visit the welcome.html page, we want that to be handled by our view function, welcome. By the way, you might notice that PyCharm puts little red lines below the import here, and hovering the mouse over it, it says Unresolved reference. Well, our code is actually correct. It's just PyCharm that's confused. I can fix this by telling PyChart where the root of my Django project is. I right‑click on the meeting_planner folder. Make sure it's the outer folder called meeting_planner, not the one inside it, and say Mark Directory as Sources Root. This makes PyCharm understand my project structure, and now the red lines go away. Now let's see if this works. I'm going back to the terminal and say python manage.py runserver. And now opening a browser and going to the welcome.html page, we see our greeting. So what happens is this, because of the URL 127.0.0.1 at port 8000 points to the Django server on my local machine, the browser will make a connection with the Django server and send a request for this page, welcome.html. In the log of the server, we can actually see this. The server tells us it received a GET request for the welcome.html page. Django then looks in urls.py, finds this line here, which matches the URL, welcome.html, with a few functions that will handle requests to that URL. In other words, this line says, if a request comes in for welcome.html, call this function, welcome. So then the welcome function is called, and it returns the text that is then sent to the browser and displayed to the user.

When It Doesn't Work
Now in case the previous demo didn't work for you, there's a couple of things to check. I'm going to start by stopping the running server by pressing Ctrl+C, as shown here. Now let's go over several things that might go wrong when you follow the previous demo. First of all, check the command you run to start the server. It should be exactly like this, python manage.py runserver. If you misspell any part of that, you will see an error. The error will be slightly different depending on which part you misspell, but it will always be something like no such file, unknown command, or something similar. If the command you type in is correct, but it still doesn't work, you might be in the wrong folder. For example, I might be one level too deep. Now I'm inside the folder that has the settings file. Running the server from here also doesn't work. So in this case, I can move a folder back up by saying cd .., and now I'm in the right location. Or if you're not sure, click the x here to close the terminal and start over completely. There are also other things to check. Check that you added the new app name website in the correct place, that is in the INSTALLED_APPS list, and not one of the other lists. Check that there's a comma on the line before and that the name of the app is exactly the name as the name of the app folder. Make sure to double check views.py as well. And make sure that your function is called welcome. It takes exactly one argument called request, and make sure that you didn't forget the return keyword here. Finally, go to urls.py, check that you're importing the correct module, website.views, and the correct function, welcome. Also, make sure you didn't misspell the name of the function in the call to path.

Django and the Flow of Control
Now that we have our own page, let's go a little deeper. We'll add some extra pages and get some deeper understanding. I'll talk about the way Django controls the flow of our application, how Django maps URLs to view functions, and the Django debugger. Let's take a moment to talk about control flow. Looking at our code, you might have noticed that it doesn't behave like a regular script. It doesn't simply start somewhere and then run from top to bottom. Instead, what controls the flow of our code is the Django server process. But when I run the Django server, it doesn't really do anything because what a web server does is to wait for incoming requests. In other words, our program will do nothing until a request comes in. To make a request, I have to visit our site. Whenever I visit a page in my browser like this, the browser sense an HTTP GET request to the server. You can think of this like a tiny text message asking the server for a specific page. Currently, if we go to this address, we get a 404, and we're going to fix that in a moment. To get an actual page, we need to enter a URL for which we've defined a mapping like welcome.html. So if I press Enter, a request goes out to the server, and the server log will now show that the server received the GET message for the URL welcome.html. Django looks at the view function mapped to that URL. So Django will call this view method, which returns our text, and Django sends that back to the browser, which then shows the message. So, this also means that every time I refresh the page, a new request is made, as we can see in the log, and the view function is executed every single time. Now to show you that the view is executed every single time, let me add a second page to the application. So this new view function is called date, and it's very similar to the welcome function in that it returns an HTTP response with a string, This page was served at. But the main difference is that I add datetime.now to the string. So in the new page that we've just created you will see the date that this function was run. To make this function work, I also have to import datetime. So at the top of the file I'm going to say from datetime import datetime. Now, in urls.py, I can make a new mapping for this function. Let's map it to date, and we also need to import the new view function here. Very well. Now the server will automatically detect changes in our code. You can actually see it in the log file. The server shows that it detected that urls.py changes, and it will reload. So, now we can go to this new URL /date. And pressing Enter, we now see the request come in for /date. Every time I press Refresh, you now see the time shown in the resulting page change. So every time the view function will be run. Now let's just fix one thing. The welcome page is currently shown at welcome.html, but I prefer it to be shown as the index page of my site at the default URL shown here, which is just a server address and port with nothing after it. We can do so by mapping the URL to the empty string like this. And now if I click this link, the welcome page shows as the default page for my site. Nice.

Adding an About Page
I'd now like to add a third page to our web app and go over some of the possible problems that you might see. If you're working along, please take a moment to try to implement it yourself. The exercise is as follows. Please add an About page that shows some text about yourself. If you're going to try to implement it yourself, pause the video right here and write the code. I'm going to wait for a couple of seconds before I show the solution. The way I do this is I just copy the existing welcome function into a new function, and I'm changing the name into about. I'll also change the text that the function returns into I'm Reindert, and I make courses for Pluralsight. Good. The next step is to add a URL mapping in urls.py, which I've already done here. As you can see, it's the last line, it says path about about. So the first argument, again, is a string and that's the URL, and the second argument is the actual view function, and you shouldn't forget to also import the view function. So that's it. We now have a new view function and the server will reload automatically so we don't have to restart or anything like that. Let's go check it out. So if you go to the new URL about, this is what you should see, or of course, you should see the text you wrote about yourself. Now let's go over a couple of things that might go wrong here. First in urls.py, you might have mistyped the about URL, something like this. In this case, if you go to the About page, you will get the 404 error because there is no mapping for about because we only have a misspelled URL right now, so let's fix that. And you might also have mistyped a name of the view function. But if you do that, you will see that the server actually gives you an error because this is not valid Python code, and this means the server is not running, and you will also not be able to connect in the browser. So there is a difference between a running server and asking for a URL that doesn't exist, and the server not starting at all because you don't have valid code. Now, let's fix this again and let's look at the view for a moment. There are two main things that beginners sometimes do wrong here. First of all, they might forget to add the return keyword in the last line. Let's see what happens if I do that. As you can see, the Django server really makes an effort to help you out here. The error is quite informative and tells you that we forgot to return a value. It also tells you that this is about the function website.views.about, so that will help you find the code that caused the error. And if you scroll down all the way, Django shows you lots of info about its configuration here. At the end here, Django tells you you're seeing this error because you have debug is true in your Django settings file. So our server is running in debug mode and that's why it shows these very detailed error messages, but you can imagine that in a production environment where your server would be exposed to the dangers of the internet, leaking this much information is not very safe. So in a production environment, you absolutely don't want to have debugs set to true. But during development, we do like this setting because it makes fixing errors so much easier. Going back to our view function and fixing the missing return, the other thing that people tend to forget is the function argument request here. Please check for yourself what happens when you leave that out.

Review
Let's review what we've learned. We started with creating a Django app using the command python manage.py startapp followed by the name of the app we want to create. Remember that the manage.py script is in the Django project folder, which in our case, is not the same as our PyCharm projects folder and that means you have to cd into the right folder before you can run this command. After creating an app, you should make sure it is picked up by Django by adding it to the INSTALLED_APPS list in settings.py. Let's take a moment to talk about what a Django app actually is. The word app, when used by a Django developer, means something very different from say, an app for your mobile phone. A Django app is a Python package that's specifically intended for use in Django projects. You can break up the functionality of your project into multiple apps that each act as little web applications of their own, with their own views, URL mappings, as well as components that we've yet to learn about like models and templates. So that means that a typical Django project consists of multiple apps. For example, let's say I create a website for a rock band. I might have an app for showing pages with information, an app that shows the touring schedule, another app for selling tickets, etc, etc. You can think of it as a way to organize your code. We put related things together in apps. A nice thing about writing apps is that sometimes you can make them reusable, so I might just reuse the ticket selling app from another site in the site for my rock band. Now I have to say that designing an app to be reusable is a little too advanced for this course so we're not going to do that right now. Structuring your project into multiple apps helps keep your code modular and organized, but you're completely free to organize your apps any way you like, so you could even decide to put everything in one huge app or not to use apps at all. But the best practice is to follow the UNIX philosophy to do just a single thing and do it well, so keep your apps simple and small. If you need more than one sentence to explain what the purpose of your app is, it's probably too large. Once we've created our first app, we can start adding code. In views,py, we added a so‑called view function, which takes a single argument, request, and returns an HttpResponse. The responsibility of this function is to handle so‑called HTTP requests for our Welcome page, but to be able to visit that page, we need to assign it the URL and this we can do in urls.py where we import our view, and in the urlpatterns list, we add a call to path, which is a function that creates a mapping from a URL to a view. In this case, we leave the URL empty because we want our page to be the root page of our site. So what happens when I view a simple web page? Suppose that, like in the demo, we used a browser to visit the locally running server at 127.0.0.1 Port 8000. Well, first of all, the browser would send an HTTP GET request to that server. If you don't know what that means exactly, let me put it like this, an HTTP request is a message from the browser to the server where the browser requests that the server does something. In the simple case of viewing a web page, it will send a get request, which means it asks the server to send it the content for some URL. When the Django server receives a request from a browser, it takes several steps to determine how to handle that request. First, it looks at the URL patterns in urls.py to see if there is a URL mapping that matches the request. In our case, the URL is matched by this line here, which refers to a view called welcome. This means that Django can ask the Welcome view to handle this request, so the next step is that Django will call the view, which in this case, is a function. And all this function does for now is to send a response with some text back to the browser, which will then be shown by the browser to the user. And that's it for this module. We've learned how to create a Django app, add a view function, and assign a URL to it. We saw how to run the server and view the page, and we've also taken time to make sure that we understand exactly how Django knows which function to call for which page, and we've looked into solving common problems. With that, let's move onto the next module where we'll start building our database model.

Setting up a Data Model
Introducing Models and Migrations
Hi. My name is Reindert‑Jan Ekker, and in this module we'll learn how to set up a data model in Django. This module is focused on creating a data model, which will allow us to create meeting data and store that in a database. We'll start by learning what Django model classes are and how to write them. Then we'll learn about database migrations and how to use those. And finally, we'll see that Django provides us with a very nice and powerful interface to enter and manage meeting data. Let's start by introducing two core concepts of this module. First of all, there's Django models. Models are Python classes and their purpose is to make our data persistent. In other words, they let us store things in a database in such a way that if you stop the Django server and then restart it the data will still be there. So when we create a meeting model class and then create a meeting object we can save that into the database, and we can reload it later after we restart the server. In Django, a model class is mapped to a database table. So a model class called user will result in a users table and a meeting class will have a meetings table. Then each object of that class can be stored in a row in that table. So if I create a new user and save that in the database the users table will contain a new row with the data for that user. Now, while you are working on a project you're changing and updating your code all the time. This is true for all your Python code, so it's also true for our model classes. For example, we might add or remove or rename properties. If I decide I want to be able to store my user's age I will add an age property to my user class. But that means that I need to add an age column to my database as well. Every time we change our model class we will need to change the corresponding database table so that it will have the right columns to store our objects. And that change to the database structure is automated through migrations. A migration is a Python script that changes the database so as to keep the structure of the database up to date with our model classes. Whenever I change my model, let's say I'm adding the age property to my user class, Django will generate a migration script that will update the database table accordingly. Actually, once your project becomes slightly more advanced Django will not be able to generate everything you need and you will need to write your own migration code. But we will not do that in this course. In other words, models are Python classes that represent your data and make it possible to save your data in a database. And migrations are scripts that help keep your database structure up to date with your model classes.

Running Initial Migrations
Let's see some of this in practice. Before we even start writing our own model classes, we can already run some migrations. Let's do that. I'm going to start by taking a step back and look at the current situation. First of all, looking at settings.py, we notice that there are a number of apps included by default in our Django projects. We can see them here in the INSTALLED_APPS list, admin, auth, contenttypes, and more. Interestingly, we see these same names pop up somewhere else as well. When we start our server with the runserver command like this, it shows this message: You have 17 unapplied migrations. And it shows you the names of some apps here, admin, auth, contenttypes, sessions. Each migration is a Python script that makes a change to the database corresponding to some piece of Python code in a model class. And there are apparently 17 migrations for these apps. So, apparently, these apps includes model classes, and Django wants to create database tables to store data from those model classes in the database. I can ask Django which migrations are waiting at the moment. First, I'm going to stop the server. And then I'm saying python manage.py show migrations. And we see here that the admin app has three migrations waiting, the auth app has 11, etc. Each of these lines you see here represents some change to the database. And mostly they are about creating the correct table structure. The next step is to apply the migrations with the command python manage.py migrate. This runs all currently pending migrations. Can we check what the result was? Actually, yes. Remember that our database is stored in this file db.sqlite3. It was created automatically when we were on the server, and at that moment, it was empty. But right now it should be different because we just ran some migrations and created some tables. Can we check that? Actually, yes. We can ask Django to make a connection with the database using the command python manage.py dbshell. Please note that this command might not work for you because you may need to install SQLite separately. In that case, don't worry. You don't need to be able to do this. I just want to show you what the database now looks like. So you can just as well sit back and watch for now. So now I have a connection with the SQLite database, and I can ask it to show the tables that were created, and you can see that there are now 10 tables. All of these were just now created when I ran the migrations. Note that each table name is prefixed with either auth or Django. Most of the time, this is the name of the app it belongs to, so we see that the auth app provides us with tables for users, groups, and permissions. And, of course, this means that for each of the tables, there will be a model class in the Python code for the auth app. There are also a number of tables with the prefix django. Those don't belong to any specific app. Let's take a short look at an important table, django_migrations. This is an SQL select statement. If you don't know SQL, that's okay. You don't need to write any to be able to use Django. And here we see a line for every migration that has been executed. It shows each migration we just ran with the exact time that it happens. So this is where Django records the current state of the database. This makes it possible to compare the model classes in your code at any moment with the tables. Now let's exit this and go on to write some more code of our own.

Creating a Model Class
So let's write our own model class representing a meeting for our meeting_planner. But before we start writing a class, we need to add a new Django app. Remember that we group related components together in apps. The website that we made in the previous module contains simple text pages. Now let's create a new app that will hold code for dealing with the meeting data for the meeting_planner. So I start by running python manage.py startapp meetings, which, as you know, creates a new Python package, meetings. And let's install the new app immediately as well by going to settings.py and adding it to the INSTALLED_APPS. Now looking at the files in the meetings app, we already understand a bit better what all of these are for. Migrations will go into the migrations folder. We'll see that soon. The admin is for configuring the admin interface. We'll see that in a moment as well. Apps.py is for advanced configuration. We're not going to do that in this course, so let's remove that one. Models.py will hold our models, and views.py will hold views. That leaves tests.py for writing unit tests, which I'm also not going to do, so let's delete that one as well. Now the place for our new meeting model will be in models.py, as the name implies. So let's open that. And let's start with adding a class called Meeting. All Django models need to inherit from the base class models.Model, which makes this an official Django model, and that means that it will represent a table in the database, as well as meetings. So how does Django know which columns that table will hold? Let's tell it. To begin, the meeting has a title and a date, and I'm saying title is a character field with a maximum length of 200 characters, and date is a date field. We'll add more fields soon, but let's start with these. Note how title and date here are a bit different than the object attributes you may be familiar with. These attributes are not set in the __init__ method like you would do with attributes on a normal Python class. These attributes are actually set on the class, so there's something special going home. Django will inspect the attributes of the class and create __init__ method for us, which creates the properties, title, and date. But it will also help us create a database table with the right columns so we can save meeting objects in the table. And it's also makes sure the database columns have the right type. So that's actually what I'm specifying here. Please make a title column in the database where we can store text and a date field where we can store dates. What the table will look like exactly depends on the type of database you use. That might be MySQL or Oracle, etc., etc. In our case, we use SQLite. Django will make sure to generate SQL commands to create the tables in such a way that our database understands it. Let's see how that works.

Creating and Running Migrations
So we've written a model of our own, and we want to be able to store the data from this model in our database. In other words, I want a table for meetings. To make this happen, I go to the command line and run manage.py with the command makemigrations. What this command does is it looks at our models and determines what changes we need to do to the database in order to make the database match our model code. In this case, it finds our meeting class, and of course there is no meeting table in the database so the migration should create those. For this to work, it's important that our app is in the installed_apps list in settings.py, as we've seen earlier. If you forget that Django will not pick up your models and it won't create a migration. The output of the makemigrations command is the file it mentions here. It's in our app meetings in the migrations folder called 0001_initial.py. Let's open this file to see what's in there. And here we see that makemigrations generated some Python code for us that represents steps needed to get our database to the right states. There's a call to CreateModel and the name of the table it creates is Meeting. And here are the fields with their types as taken from our model class. So you see the title and date fields here, but there's also a new field called id which is a primary key. This means the database will automatically add a unique number to each new row so each object we create will have a unique ID. Running this migration script will result in SQL being executed against the database. And the migration script is not written in SQL because the migration is independent from the actual back end. In other words, we might run this against SQLite or MySQL or PostgreSQL or any other database and every time it will result in slightly different SQL because each database engine has its own SQL dialect. To see the actual SQL this migration will run I can use the sqlmigrate command. We call this command with two arguments, the name of our app and the name of the migration. You don't have to type the entire name of the migration. Usually just typing the number it starts with is enough. So here you can see that the migration will cause a CREATE TABLE statement, and we see that it creates the id column, a title column, and a date column. Now to actually run this SQL and create a table I say python manage.py migrate. This will run all currently waiting migrations from all the apps in my installed_apps list. You can see it runs the new migration from our meetings app. And if I now look at the database we see that we now have a meetings table. Note that the name of the table is prefixed with the name of our app meetings. The part after the underscore is the name of the model class, meeting.

The Admin Interface
So we've created the meeting class, and there is now a database table to store meetings in. But how do we actually create meetings and store them in the database? Well, Django comes with a handy auto‑generated interface called the admin interface that lets you create and edit model data. To use it, we'll have to register our model with the admin site and configure a superuser account to be able to log in. Let's take a look. The admin app comes with Django by default. And as you can see, here it is in the installed packages setting. There's also some admin‑related code in urls.py. The urlpatterns list by default includes this call to path. This works slightly differently than our own mappings because the admin interface is different. Let me just say that usually you will not need to map things this way because it's a special thing for the admin. To be able to create and edit meetings in the admin interface, we need to change this file in our meetings app, admin.py. Let's start with importing our class. And now I can register it so it will show up in the user interface. So that's all the setup we have to do. Let's go and start the development server and open a browser. As we saw in the URL configuration, the admin site is hosted under /admin. So that's the URL I want to visit. And apparently we need to log in here. But we first need a user account. Let's make one. I'm going to stop the server and run manage.py createsuperuser. Here you get to choose your username, fill in your email address, and choose a password. Now Django does validate your password to see if it's strong enough. But because this is a development server, I can tell it to bypass the password validation and create the user anyway, even though I have a weak password. Now that I have a superuser, we can use this account to log in. The interface you see here is completely auto‑generated by Django. As you can see, there are already three models here, users, groups, and meetings, and the users and groups are always present because they're defined in the auth app that's installed by default. Now our project doesn't use groups and users right now, so, instead, let's click our own model and add a couple of meetings. As you can see, Django knows how to generate a nice HTML form for our model fields. So there's a text field here for the title and a date picker for the date fields. Let's say I have a meeting with my project team about my project requirements, and that meeting is tomorrow. And I'm going to click Save and add another. So let's say I have another meeting on the sixth where I will present the progress of my project to management. And let's save this. This brings us back to a list of all existing meeting objects. Right now, the way our meetings are listed here is not very informative. It just has Meeting object (1) and (2). But we're going to fix that in a moment. For now, you should understand that this number here is actually the unique ID for each object. Remember that Django added an ID column to our meeting table. Well, when you save an object, this ID automatically gets a value. So that's where the 1, 2, etc. comes from. So the admin interface is very convenient and powerful. It's a very nice way to create and manage data for your site. But the admin interface is called the admin interface because it's meant to be used by administrators. This is not your site. We're not going to use this as the front end to show to our users. Actually, our users will never see this admin site, and in the next module, we're actually going to start building a user interface for the end user.

Review
Let's do a bit of a review of what we've learned so far. This whole module is centered around Django models, and the entire purpose of models is to make it possible to save our Python objects in a database so that the data keeps existing after the server stops running. We've seen that our model classes are mapped to tables in the database. In other words, when I create a meeting model, this will result in a corresponding meeting table in the database. And in the table, the columns correspond to the fields of my model class like the start time and the title. This allows us to work with the database just by writing Python code. Django will make sure to generate the SQL for what we want to do and run that against the database. It creates the tables and columns for our model classes when we run migrations and executes the SQL we need to update, insert, or delete data when we manage our data through the admin interface. In the standard Django install, there's support for several databases, PostgreSQL, MariaDB, MySQL, Oracle, and SQLite, but those are not your only options. You can store your data with many other database engines as well through third‑party libraries, which gives you support for IBM DB2, Microsoft SQL Server, and many other back ends. We've seen how to write a model class for which Django can generate a database table, and these classes usually go into a file called models.py and then have to inherit from the Django model superclass, which is in the django.db.models module. Any class that inherits from that superclass will be mapped to a database table. The name of the table is taken from the class itself, although you can set a different name if you want to. Then, in the body of the class, you define the model fields. And in the example here, we have a CharField called name and an IntegerField called age. So how do you know which types of model fields there are and what options they take? In this course, I'm not going over all the possibilities because we have too much ground to cover, but let me show you what you can do if you want to know more. I usually just go to a search engine and search for Django model fields, and this takes me straight to the reference documentation that tells you everything about the different kinds of fields and the options they take. Scrolling a bit down on the right here, you see a long list of all the different kinds of fields you can create with Django. When you're writing code for your models, you will be changing your database a lot. As we've seen, Django automates this for you, but make sure that you have installed your app by adding it to the installed apps list in the project settings, or otherwise, Django will not see your models. So, the workflow usually goes like this. Suppose you make a change to a model class. You then call the makemigrations commands to generate a migration script that reflects the change in your model. It's always wise to check the code Django generated to see if it does what you had in mind. Sometimes you want to see an overview of all migrations and which ones have already been run. You can do this with the showmigrations commands. Finally, you can run the pending migrations with the migrate commands. So, to register a model with the admin site, we only have to add a very simple piece of code in admin.py. Of course, you need to make sure that you import both the admin package and your own model class, and then you can simply say admin.site.register and pass your model as an argument. Of course, if you want to log into the admin, don't forget to create a superuser with manage.py createsuperuser.

Bringing It All Together
So how does all of this translate to the daily work of a developer? Let's see some more demos that go over the entire workflow again. We're going to create a new Model class, run migrations, and make it editable in the admin interface, but this time, we'll also add a foreign key, which enables us to store a reference from one class to another in the database. Let's add some more fields to our Meeting class and see. I'm opening models.py, and here, I've added two new fields, a time field for picking the start time of the meeting and a duration in hours, which is an IntegerField. Now we've changed the model, I need to add these two fields as columns to the meeting table in the database. So the next thing I do is add a migration with python manage.py makemigrations. And now, we get a message here, you're trying to add a non‑nullable field start time to meeting without a default. Why is this a problem? Well, when we add the new column for the start time, we also need to provide a value for the new field for every row that is already in the database. So we already created two meetings in the admin interface, and those will also get a start time and a duration field and empty fields are disallowed by Django, by default. So Django is now asking me how I want to solve this. Well, I'm going to press 2 to quit and let's add some default values to our fields. First, let's import the datetime module, and then I'm setting the default starting time to 9:00, and the default duration for a meeting will be 1 hour. So you can set the default value for a field by saying default= followed by an appropriate value, so a time for a TimeField and an integer for an IntegerField. Now let's try to create a migration again. Now we see a new migration is made and, of course, this will be a new file in the migrations folder and we can open it, and here we see that the script contains two add field operations, adding a duration and a start time, including the default values we just added. Now the last step, of course, is to actually run our migration by saying python manage.py migrate and this will actually add the columns to the database. Now, before we check out the results in the admin interface, let me add a string representation to our class by defining the __str__ method that returns a string with the title, the start_time and the date of the meeting. Now you might wonder if we also need a migration after adding this function. Let's see. I'm going to run make migrations, and now this tells me that nothing has changed. This is because we have not changed any of the model fields, we only added some behavior and that's not part of what will be stored in the database. So let's run the server and going back to the admin interface and reloading, I'm going to click here on my meetings and the way our models are now displayed is a bit friendlier. If I click Add meeting, we now see all four of our fields and the default values are filled in already. So before we continue, feel free to explore the admin interface and see what you can do with it.

Adding a Second Model Class
Now let's practice the whole models and migrations workflow another time. First, I want to ask you to try something for yourself. Please add a mobile class called Room to present a meeting room, and the room has a name of floor number and a room number. If you're going to try to do this, please pause the video and write your code. I'm going to wait for a couple of seconds before I show you the solution. So here is the code I wrote for this. The classroom, just like the class meeting, inherits from models.Model and we give it three fields, a name, which is a character field, so that's equivalent to saying it's a string, and I give it a max length of 50 characters. We also have a floor number and a room number, both of which are integer fields. I also added dollar str method so that the rooms we create will look nice in the admin interface. And like we've done before, we create a migration for this and run it. Very well. Now, when I plan a meeting, I want to be able to select a room to meet in. To do so, I'll add an extra field to the meeting class. So here I say, room is models.ForeignKey, and this adds a foreign key relation from the Meeting class to the Room class. A foreign key is a concept from SQL databases, and I'm not going to explain the details about it, but what it comes down to is that this field will hold the ID of the room object that this meeting references. In a moment, we'll see in the Django admin that this will make it possible for us to select a room when we create a meeting. Now the only lead argument here is required, and this is also a database specific thing, it determines what happens when a room is removed from the database. By saying CASCADE here, I'm saying that if a room is deleted, all meetings for that room will also be removed, and that seems sensible. There are also other options, but that's very much a database topic, so I'm not going to discuss that in depth right now. We're not allowed to create a foreign key in Django without specifying the on_delete behavior, so that's why I put it in here. Now again, let's make a migration and here is the same warning that we've seen before. I'm adding a column room without setting a default value, so Django is asking what do you want to do with the meetings that are already in the database? Which value do you want to put in this column for those meetings? Well, actually, I don't have a good answer to that, so let's hit 2 for quit, and instead of fixing this problem, I'm going to make my life a bit easier. First, I'm going to throw away all existing migrations. Make sure not to remove the init.py file here, so I'm just removing the migration files from the migrations folder in the meetings app, but the init.py file stays. Next, I'm also going to remove the database. This gives me a completely clean slate for the database. Now I can say makemigrations, and because right now we have no database, it will see no existing database table and also no existing meeting objects, so it will create one single migration file with both my models meeting and room and other fields in a single file. Here it is. So looking at that, we now have a single migration that contains code for both the room and the meeting model. Now let's run the migrations, and I see that all the default migrations for an empty project run again because, of course, we're running it against an empty database so it has to rerun all the migrations, so everything runs without any annoying questions or warnings, but the downside to this is that you lose all the data you entered. Now, when you're working on a new project like this, that's not a big problem at all. Losing all data also means we have to recreate the super user. And now, before I run the server again and start creating new rooms and meetings, we also need to make sure that we can actually use our room class from the admin interface. So we have to add the new room class to the admin interface in admin.py. So here I'm now also importing the new Room class and registering it for use in the admin site. Now finally, we can run the server again and let's go to the admin interface, and let's go and create a meeting, and down here, we can now select a room, but of course there is no room yet in the database, but the little plus sign here allows you to create one on the fly, so let's do that. And let's say we have a large conference room, which is room 21 on Floor 2, and I click Save. And now I can select this room here. Now clicking Save, this is the overview of all my meetings, going back to the home page and selecting rooms, you can now see we just created a room. So this shows you that by adding one line to our model, namely this foreign key here, the admin interface gives us a very convenient way to create model data and link those objects together. In the next module, we'll start creating a user interface for the actual users for our meeting planner. They will not be able to create or edit rooms, just meetings, so that shows you already for whom the admin is meant, it's for the administrator who can actually edit the rooms. And that brings us to the end of this module. We've learned how to set up a data model with Django, we've created two model classes, created and run the migrations to shut off a database, and used the admin interface to create and edit data. Now let's move on to the next module, where we'll learn about templates and the model template view pattern.

Combining Model, View, and Template
Introducing Templates and the MTV Pattern
Hi, My name is Reindert‑Jan Ekker, and in this module well add templates to our project and learn about the MTV pattern. Just about every modern web framework, and that includes Python frameworks, follows the same basic pattern called Model‑Template‑View. You can see this as a set of best practices for how to organize your code. There are three types of components: models, templates, and views, and each have a clear responsibility. In this module, I'm going to teach you how to implement this better in Django. By the way, you might know the same pattern by the name Model‑View‑Controller, and that is actually the same thing by another name. In the world of Python web frameworks, people are just used to calling it MTV instead of MVC. Now views or view functions and model classes we've already seen. So to make our application follow the MTV pattern, we have to add templates, and then we need to make all three components work together. We'll see how to use our data model from a view function, and call a template from a view function, and we'll see how we can use URLs to pass parameters to our view functions, and how to return a 404 error when that's necessary.

A Template for the Welcome Page
Let's start by implementing a new kind of component called a template. Templates are the components that are responsible for displaying our data to a user. In a web application, displaying data means creating a web page, so we'll use these templates to generate HTML that's the browser can display. We'll see how to call these templates from the view and how to pass the data we want to show from the view to the templates. Let's look at our welcome view function. So far, we've written views that return strings, and those strings are the content of our pages. But in a real application, you would want to create beautiful pages with HTML, and that HTML can become quite large and complex, and putting large amounts of complex HTML in a string in your Python code is not really nice. It's better to create a separate component called a template that will generate that HTMl while keeping your Python code nice and small and clean. Now, Django has a default location where it expects these templates to be, and we need to make this ourselves. So let's create a folder here. It has to be in our app, and let's call it templates. Now, make sure to call these templates. Don't forget the s here or this will not work. Now, the best practice is not to put your files directly in the templates folder, but to create another folder with the name of your app. So here I create another folder called website. We do this to prevent name clashes. Several apps might have templates by the same name, but putting them in a fuller with the name of your app, makes sure we can tell them apart. So in here I will create a new HTML file. If your editor doesn't have this option, simply create a text file with this name, welcome.html. So here we see some code that's given to us by PyCharm. It's a very minimal HTML file and it has all the basic building blocks for HTML. The first line is a DOCTYPE, which marks this is an HTML5 file. Then we see the html tag, which wraps the entire document, and we see a head and the body part. The head contains metadata. So that's data about this document. For example, here you see the character set for this file, and you can add information about the author or the language, etc., etc. In this case, I'm going to set a title here, and this will show up in the browser's tab. Let me fill it in. I'm going to set it to Welcome, and the body will contain the actual content for our page. I'm going to copy/paste some code in here, and what we see here is an h1 tag, which will show in the browser as a header saying, Welcome to the Meeting Planner, followed by a paragraph tag containing some text. This is the demo application for the course, Getting Started with Django on Pluralsight. There's a link here pointing to the Pluralsight homepage, which will be clickable. Now to make this page actually show up in the browser, we have to use this template from a view function. Let's go back to our views module, and in the view function, instead of just returning the text for the page here, I will now call a function called render. By the way, this is already imported in the line at the top. This line was added when we generated our app. Now the first argument we give to render is request, which is also the first argument of our view function. This is an object that holds all kinds of information about the request that the browser sent, like cookies, HTTP headers, and more. Right now, we will not use it, except to pass it through to the templates. The second argument is the name of the template file that we want to render. When the function is called, Django will look for a file called welcome.html inside a folder called website, inside the templates folder, and it will find the template we just created. At the moment, our template file is simply a plain HTML file, and this function call will just return the contents of our template file. In turn, we return that value from the view function, and the Django server will make sure to send it to the browser. So going to the browser, we see this page, with exactly the content from HTML page. Now in case you're working along and you get an error, let me go over some pitfalls. First of all, what happens a lot, again, is that you forget to use the return keyword here. This happens to the best of us. We've already talked about this mistake in the previous module, and you would see the same error as before. I just wanted to remind you that you shouldn't forget to say return here. Another thing that happens frequently is that the templates folder is not named correctly. So make sure it's called templates with an s at the end. and that it's inside your app. And inside templates, there should be another folder with the name of my app, website. The argument to render template should match the path to the template file relative to the templates folder. So, starting from the templates folder, we go into the folder website and find welcome.html. As an example of what can go wrong here, let me remove something. So removing a letter here, now we see another error in the browser, TemplateDoesNotExist. So if you see this error, you may have a problem with the name of your templates. Now let me fix that. And before we move on, there's one last point I want to make about templates.

Template Variables and Dynamic Content
This template file looks like a regular HTML file, but it can actually be a bit more than that. Let me insert something. Now this here, the structure with double curly braces, is called a template variable, and it's a placeholder that will be filled in by Django when the template is rendered. We can supply the value for this variable in the view method by adding a dict as an extra argument. This dict has a key called message with this string as a value. So now every time Django receives a request for this page, the view function will run, and it will pass this dictionary to the template, and this string will be placed here in the HTML. Soon we'll see that these values might come from a database, and this allows us to have dynamic HTML pages where the content of the page is not always the same, but changes with circumstances depending on who's logged in or a form you filled in or a product you selected. So we call this file welcome.html, a Django template, because it's not actually an HTML file at all. It's a template for an HTML file. Only after Django fills in these placeholders with the values provided from our view function do we have an actual HTML to send to the browser. Now a question I get asked a lot is, can I use these template variables everywhere in my HTML? And the answer is yes. You see, as far as Django is concerned, this is just a text file with placeholders. Everything that's not a placeholder or some kind of special template syntax is left alone by Django and sent to the browser as is. If I want to set a placeholder somewhere in the middle of an HTML tag, let's say here in the link, that's totally fine. Let's also give a value for this new variable x in the view. And now, refreshing the browser, first of all, we see the message here, This data was sent from the view to the template, so the output from the template variable called message. We also see that the link to Pluralsight is now broken. Why is that? Well, let's look at the source code for this page. Here in the tag for the link is the value 42, which was inserted there by Django, and this obviously isn't correct HTML. So, that's why the link doesn't work. This goes to show you that you can use template variables everywhere in the text. Django doesn't really care that this is supposed to be HTML and just fills in the placeholders you give it. Although soon we'll see that it can do a lot more than that. Let's remove the code that broke the link, as well as the part that's in the dictionary. So, the files in the templates directory dynamically generate HTML pages based on the data that our view functions send to these templates.

Review: Templates
We've just learned about templates, and they are the components from the Model‑Template‑View pattern that we used to display our data. Django includes its own templating system, which is a way to generate text files, and in our case, we use it to generate the HTML files that are sent to the browser and displayed to the user. The templates that we write are also text files containing special place holders for variables where data can be filled in, and that's how the actual HTML is generated. Actually, Django templates can do much more than that; they support if statements, for loops, and many more things. We'll get back to that later. So here's an example of a general template for HTML. You can think of it as an incomplete HTML document containing placeholders to be filled in. The placeholders are the parts highlighted in orange. They are names of variables in double curly braces. The values for these placeholders are looked up in the template context. This is like a dictionary containing names and values. All the other text outside of the Django variable blocks is just copied to the HTML output as it is. So in this way we can create dynamic HTML pages. The content of this page will vary, depending on the value of the variables in the context. Simply creating the template is not enough. It's the responsibility of the view function to call the correct template for a page. To do so, we call the render function, and you pass it the request object, as well as the name of the template file you want to render. The third argument is a dictionary containing names and values of variables to be passed to the template as the template context. Django will look for the file welcome.html in a folder called templates, note the s at the end, and this folder should be inside the app that also contains the view code. Django will fill all the placeholders in the template and return the HTML page ready to be sent to the browser. And don't forget to actually return the HTML contents from the view function. If you don't, you will see an error.

Completing the MTV Pattern
Let's see how we can combine the model view and template. We'll start with a relatively simple page that retrieves some meeting data from the database and sends that from the view to the template so we can show it to the user. Then we'll apply the same pattern in a slightly more realistic and useful example. I'm going to implement a so‑called detail page for meetings. This means we will take a meeting object from the database and pass it to the templates. But we also want to make it possible for the user to select which meeting to show. We'll learn how to change the URL mapping so that it takes a parameter to select a specific meeting id. This will also make it possible to select a meeting that doesn't exist. So for that, we need to write error handling code to return a 404 error. So let's say my template looks like this. It shows the user the number of meetings currently in the database, using a variable called num_meetings. Now, looking at the view, like before, here's our render function, and I'm still passing it a dictionary, and this dictionary is what we call the template context, and it's where Django will look for the num_meetings variable. The code here is where I retrieve the number of meetings currently in the database. Each model class, like meetings, has a property called objects that lets us retrieve information from the database. One thing you can do with objects is to call count, which will return the number of rows currently in the meetings table, which we then pass to the templates. Of course, we also need to import the meeting class from the meetings app, and I'm doing that here at the top, from meeting.models import meeting. So, refreshing the page in our browser, we see the information that we retrieved from the database in an HTML page generated by a template. This means that we have now built a page with the complete Model‑Template‑View design pattern.

Taking a Parameter from the URL
Now let's apply the same pattern again to create a page that shows the details for a meeting. I'm going to go into the meetings app and open views.py. At the moment, this is quite empty. Let me add a view function. This function is called detail, and it will be the view function for the detail page for a meeting. In other words, a page showing all the detailed information for a single meeting object. There are two new things in this view function. First of all, it takes two arguments. So not only a request, but also an argument ID. This will be the ID of the meeting we'll show on the page. The other one is this function call here, Meeting.objects.get. The meeting is an object attribute we've seen before. It's actually called the model manager for the meeting model class, and it allows us to retrieve things from the database. Earlier, we used this to get the number of all meeting objects in the table. Right now, I want to get a single meeting object, and I do so by calling Meeting.objects.get and passing the ID as an argument like this, pk=id. Pk here means primary key, which to our database means the row with this unique ID. And the result is that the database will find the row with the given ID, return the data in that row. Django will then convert that back into a real Python meeting object, which then assigns to the variable meeting here. Next, we call the render function and pass it our meeting object in a dictionary so it can be shown in the template, and the name of our template file is meetings/detail.html. Now all of that is nice, but how is the user going to input the value for the ID? Well, we can put that information in the URL of the page. So here's our urls.py. Remember, it's in the meeting_planner folder. And let's start by importing our new view function. So I say from meetings.views import_detail. And now let's add a URL by calling path like we've done before. So, like we're used to, the first argument here is the URL and the second is the view function. But the URL now has an interesting new piece of syntax. It says meetings/, and then a less‑than sign followed by the text int:id, and ending with a greater‑than sign. This is a special piece of syntax that Django can understand. What we're saying here is that we expect an integer, so a whole number, after the slash, and the value of that should be passed to the view function as an argument named id. So now the user can go to the URL meetings/2, and that should return the meeting with index 2. But before we can test this, we need to look at one more file, the templates, which is in meetings/templates, then meetings again, and then detail.html. So this is a very similar page to the welcome page we saw before. The meeting variable will hold meeting objects, and we use it in double curly braces to retrieve the title of the meeting and use that as the page title. We also get the date and time and the room as well. So let's go and test whether this works. If we go to meetings/1, we see our first meeting, and meeting/2 gives us the other meeting. So the number we put into the URL here is matched by this part of the URL mapping and then passed to the view function as the ID argument. The view function retrieves the meeting with that ID and passes it to the template.

Returning a 404 Error
When we enter an ID that doesn't exist, though, we get a debug view showing a DoesNotExist error. Let's see what happens here. So when the user requests a page meetings/1, this matches the URL rule for our view function and the id parameter gets the value 1, which causes the meeting with index 1 to be retrieved from the database and shown to the user. That's all well and good. When I use an index that doesn't exist in the database, this line here will throw an index error. You could, of course, decide to handle this by wrapping this line in a try‑except block, and then handle the index error yourself, but Django actually has a nice utility to help us with this. We can import it on the first line, and it's called get_object_or_404. And we can replace our call to objects.get with a call to this function. This function will now call objects.get for us, but we have to pass in our model class, Meeting, as its first argument. It will call objects.get on the meeting class and pass it the second argument, pk=id. The nice thing is that it also handles the case where the id doesn't exist. In that case, because the user is asking for something that can't be found, the correct response is to return an HTTP 404 not found error code. So that explains the name of the function. It will either get an object for the given class with a given id, or it will return a 404 error to the browser. So this result with a non‑existing index now results in a 404 not found page. It's still an error, but a more correct one. By the way, if you were to enter something that isn't an int, this also results in a 404 page. And the same is true if you leave out the index altogether. This is because, looking at our code, we have specified that the URL for this view is meeting/, followed by a number, so none of these other cases matches this pattern, and that's why Django returns a 404. No URL mapping can be found for those URLs.

Review
The Model‑Template‑View pattern makes up the core structure of a Django web application. It consists of three types of components, the view, which defines the behavior for a page. Its responsibility is to determine how to send the appropriate content to the client. The views we've seen so far are functions which we map to a URL using a pattern in urls.py. The template has the responsibility to create a user friendly presentation, and it does so by generating an HTML page to be shown in the browser. And then there's the model, which represents the data that lives in our application. In Django, we write model classes, which are mapped to database tables. All of this might seem familiar to you. You might know this pattern already by another name, Model‑View‑Controller, as it's known pretty much everywhere outside of the Python world. So how do these components work together to serve a web page? Well, as you know, a Django application does nothing on its own. Everything has to start with a request from a browser. So let's say I go to the URL /meeting/1 in my browser. What happens when I press Enter is that the browser sends an HTTP GET request for this URL to the Django server. Django will look up this URL in urls.py and see that it's mapped to our view function. The view function is responsible for determining how to form a response, and that means it needs to determine whether to call the template or the model, in what order, etc., etc. So in our case, we first call the database, which returns the data for our meeting. And then we send the data to the template, which returns an HTML page with the data filled in, which we then send back to the browser. And the browser shows the page to the user. So this is the whole flow through the complete MTV pattern in a Django application. And in my opinion, understanding this flow and the responsibility of each component is one of the main keys to becoming a proficient web developer in any framework. When you really understand the order in which each component does its task and how information flows between them, you are already a step ahead of the competition. In our view functions, we've now written code to retrieve model data from the database. And we've seen that model classes have a .objects attribute, which will allow us to retrieve that data. Let's go over some functions that you can use on this .objects attribute. First of all, there's .objects.all. And this will retrieve all rows from the table and return a list of all the objects. So saying Meeting.objects.all will give you a list of meeting objects that represents all the rows in the meetings table. Now we haven't seen this function in practice yet, but we'll see that soon in the next module. What we did see is Meeting.objects.count, which will give you the count of all the rows in the table. And we've seen Meeting.objects.get, which will retrieve one specific object by ID from the database. Our meeting detail view has an argument ID so we can tell it which meeting to show. We try to retrieve a meeting with that ID, and if there's no such row in the database, we want to show an error. This is such a common thing to do that Django has a very nice shortcut method for it called get_object_or_404. It does exactly what the name implies, which is retrieve an object or show a 404 error. If you look at the last line here, you'll see how to use this method. We call get_object_or_404, and we pass it as the first argument to the model class that we want to retrieve an instance of. Next, we say pk=id. So we're retrieving the object with a given ID as its primary key. This will either result in a 404 error being shown to the user or a meeting instance being assigned to the meeting variable. We also saw that it's possible to add parameters to your URLs. An example of this is shown in the code example at the top. The part in orange says <int:x> between angle brackets. This expression will match a number in the URL and assign that number to the view parameter called x. In other words, if the user browses to the page /example/5, the my_view function will be called with the argument x having the value 5. So this is a way to use paths of URLs as inputs for our view function. By the way, if a request comes in that doesn't match this, like /example/hello, this doesn't match the URL mapping, and you will receive a 404 error. In this module, we learned about the Model‑Template‑View pattern and added templates to our project to make the pattern complete. To make all the components work together, we learned how to call the model and the template from our view functions. We also learned how to take view parameters from URLs and return a 404 error when appropriate.

Urls and Link Building
Project Structure Overview
Hi. My name is Reindert‑Jan Ekker. In this module, we'll get some deeper understanding of URLs and learn about link building. This module is focused around URLs and the best practices for doing your URL mappings in Django. One thing we're going to look at is link building, which is the practice of automatically generating URLs for the links in your pages based on your URL mappings. To be able to do link building, we need to name our URL mappings, and we'll also reorganize our URL mappings a bit to follow best practices for working with our Django apps. Along the way, one of the things we'll learn is how to use a for loop in a template. Now before we start writing code, let's go over all the files that we currently have in our project because, frankly, the whole Django project structure can become confusing very quickly. So what do we have? At the top level, there's the django_getting_started folder. I created this with PyCharm, and it's a folder that the holds the Django project. So it's not the Django project itself. Inside there, there's the meeting_planner folder, and this is our actual Django project, which we created with the Django admin script saying Start project. So this is where all our Django files live. Now inside the meeting_planner folder, there's another meeting_planner folder, and this is our core project folder. Let me open it. It contains settings.py with all the project settings, including the INSTALLED_APPS lists, where we install our apps, and urls.py, which contains all our URL mappings. By the way, we're going to break that up into multiple files in this module. Then there are two app folders, meetings and website. The website folder only has the views.py, which contains a welcome view, date view, and about view, and it has the templates for some of those pages as well. Let's look at our other app meetings, and the idea of the meetings app is that it should contain all code about meetings. So, first of all, there's models.py here. We also have a views.py inside the meetings app. The meetings app has its own templates folder with the template for my detailed view. Because my meetings app has models.py, it also contains a migrations folder that contains the database migration scripts. Finally, in the topmost meeting_planner folder, there's db.sqlite3, which contains our data. And there's the manage.py script, which allows us to run commands like manage.py start at run server. Good! I hope that gives you a clear overview of all the files we have and that we're now ready for the next demo.

A Template with a For Loop
To make our site a little more user friendly, it would be nice if there was a way to navigate to the meetings from the home page. To do so, we need to add links to our home page, and to do that we need something called link building, which means we're going to generate the URLs for our links from our URL mappings. One of the things we need to make that work is names for our URLs, so we'll add those, and we'll see how to implement a for loop in a template. So let's add some links to the home page. Here's my welcome view, and at the moment, it gets a count of all the meetings in the database. Let's change the line a little and get all the meeting objects instead. Instead of calling count, I'm now calling objects.all. And let's change the variable name into just meetings. What happens in this case is that Django will retrieve all objects from the meeting table and store them as a list in this variable. Well, actually, it's a little more complicated since Django doesn't actually retrieve anything from the database until we start displaying the contents of the list in the template. But I don't want to go very deeply into that right now. It's a good thing to be aware, though, that what Django is doing here is more complicated under the hood than you can see from the code right here. Let's move to the templates. Now before we continue, if you're like me, you're now wondering, What happens if I use this template right now because it uses num_meetings, and we've just removed that from the view? So the num_meetings variable doesn't exist anymore. Will we get an error or not? Let's check in the browser just to be sure. And this is what we see: There are currently meetings in the database. So a template doesn't given an error if you use a variable that doesn't exist. It just prints nothing. So here this expression, num_meetings, right now, it just does nothing. The variable doesn't exist, but that's not really a problem. The template just ignores it. So you should be aware of that if you use a variable in your template and you don't see any output. It might just be a misspelling of your variable name. Now I'm going to remove this paragraph because we don't need it anymore. And I'm going to copy/paste some code in here. And what I've added here is a header, Meetings, followed by a ul tag, an unordered list. And here we see a new piece of Django template syntax, curly braces and percent signs. This is the Django template syntax for a statement like if or for. In this case, I'm making a for statement. This works very similarly to a normal Python for statement. But there are some differences. A for statement in a template needs to have an endfor, as you see here, marking the end of the block. We say for meeting in meetings, looping over the meetings variable, which will hold all meetings from the database because that's what I've passed from the view function. Each of these meetings will be assigned to the new variable meeting one by one. And every time we go through the for loop, the entire block gets evaluated, and the resulting text gets included in our page. So this will generate as many li tags and links as there are meetings in our database. Inside each link tag, we have the href attribute, which takes the URL to link to. Here we construct the URL for each meeting object. So here I'm saying /meeting/, and then I use a template variable expression with two curly braces to add the ID of the meeting object. So this will generate the URL for the detail page of that meeting. Let's test this. On the homepage, we now see a list of our meetings. Clicking on one of them takes me to the page for that meeting, so that also works nicely. So this list we see here was generated by the for loop in the template. Looking at the source code, this is the part of the HTML that was generated by the for loop. Each li tag with a link inside corresponds to a single meeting and to a single iteration through the for loop. The text is exactly the same every time, except for the index in the URL and the text inside the link. And here's the for loop again for you. Note that the ul tag that creates the list is /outside/ the for loop because we only need that tag once. Inside it, I start my for loop, and inside the for loop, I create an li tag and a tag for every meeting. The parts of the text that change are created by the template expressions with double curly braces. And don't forget to end the for loop with an endfor statement.

Link Building
Now here's something else to think about. Currently, our view and template are tightly coupled, and that's a bad thing. What do I mean by that? Well, if I decide to change this URL mapping for the detailed view to something else, this breaks the template because the template has a hard‑coded link. And if you have hard‑coded links in all pages on your site, you will make it very hard for yourself to maintain your templates when URLs change. Think about a scenario where you have 100 pages that link to the meeting detail page. Then, if you change this URL mapping, you will have to update all those pages. But there's a better way. Django defines a special template tag called url, which looks up a specific URL mapping. We use a curly brace and percent sign to call it, and we pass the name of a specific URL mapping. In this case, it's the detail view in the meeting set. After that, we can add any arguments to pass to the view function. So here's the meeting.id. Django will now look in its URL mappings and determine the correct URL to put in the HTML to create a working link. So let's test this out. Unfortunately, we get an error here, NoReverseMatch. And that is because we didn't give our URL mapping a name yet. Let's go to urls.py, and here I can give my URL mapping a name by adding name is detail. Let's reload the home page, and here we see our list with links again. Let me click one, and this works. Now if I decide to change my URLs now, let's say by adding somethingdifferent in front of the URL, now if I reload the home page, the links still work. But as you can see, the URL of the detail page has now also changed. So that means the actual URL in the links on the welcome page has changed as well. And that's because, in the template, we're using the url tag to dynamically generate URLs, instead of hard coding them. Of course, now, before we continue, let me remove this nonsense from our URLs. Now I have a little exercise for you. Here's the template for the meeting detail page, and I'd like you to apply what we just saw. So here's a little exercise, Please add a "Home" link to the welcome view here Using the {% url %} template tag. So please take a moment to try to add the HTML code for a link, that links to the welcome view, using the {% url %} template tag. You can pause the video. I'm going to wait a few seconds. And here is my solution. I hope you got something similar. If you couldn't work it out, that's okay as well. Just keep practicing. At some point, you'll get it right, too. So here's my code. I used the HTML a tag to create a link with the href attribute, and that takes the actual URL to link to. And to generate the URL I linked to, here I say {% url, this is a Django template syntax, and I say I want to link to the 'welcome' view. Note that I say 'welcome' between single quotes. Then I close the Django template tag saying %}, and then I say Home. And that will be the clickable text for the link. Now on its own, this is not going to work. Right now, if I go to one of my detail pages, I get this error, NoReverseMatch, and it says, Reverse for 'welcome' not found. 'welcome' is not a valid view function or pattern name. Well, this might ring a bell, so it's not a valid name. Why is that? Because we didn't give our URL mapping a name. So looking at urls.py, what I have to do here is to add a name to the URL mapping for my welcome page. So that looks like this, name is welcome. Now, if I refresh the page, here's my detail page, and now I have a home link, and if I click it, I go back to the welcome page. So again, here we have our URL mapping, it now has a name, and that enables us to use the url tag here to generate the correct URL for the welcome page. We call this link building.

Listing All Rooms: An Exercise
The next part we build I would like to do together with you as another exercise, but this time it's an exercise in which all parts come together, so it's going to be a bit more complex. It goes like this, Please add a new page that shows a list of all room objects. Before we start, it's a good idea to go into the admin interface and create several rooms. To give an example, here's my list of rooms. So make sure to go into the admin interface and add some rooms for yourself so we have some data to practice with. So the idea is to create a page that shows this data to the user. To be clear, it's okay if you just show a bit of text for each room. There's no need to create links for every room. So to do this exercise, you'll need three things, a view function, a template, and a URL mapping. Now this is quite a bit more complex than the other exercises we've done so far, so just try to do this step by step. If there's any part you cannot figure out, that's okay. Just watch a bit of the solution and then try the next step. It's okay if you cannot do it all. You're learning after all. So now you may pause the video if you like. I'm going to wait a couple of seconds before I start showing the solution. So, let's begin with the first step, and that's the view function. Here's my solution. I call this function rooms_list, and, as always, it takes an argument, request, and it calls the render function, passes the request object, and then the name of a template, meetings/rooms_list.html. It's okay if you name your function or your template differently, but it's best practice to put your template inside the meetings folder because we're currently working in the meetings app. Of course, to make this work, don't forget to import the Room class at the top. Next, we have a dictionary, which is also passed to the render function, and I call Room.objects.all, and this is the core functionality of this view function. To retrieve all room objects and pass it to the template, I assign it to the key "rooms" here, but if you called it something else like r, that's fine as well. Just make sure that you use that name in the template as well. The next step is the template, which, in my case, I'm going to put in meetings, templates, meetings, and then rooms_list.html. The HTML here has the familiar structure that we've seen before. An html header with a title tag where I say Rooms and a body. Most of these things can be slightly different or even completely absent, and everything will still work. Here in the body is where I do the actual work. I have a ul, an unsorted list, with a for tag where I say for room in rooms. Rooms here refers to the key in the dictionary that I passed from the view function. Then in the for loop, for every room, I create a list item and print the room. Now if you use something else here like room.name, that's also fine as long as you print some information about each room in this loop. The third step is the URL mapping. Let's open urls.py, and here I'm going to add a mapping for our new view function. For the URL, I pass the string rooms, then I pass the view function, which is named rooms_list, in my case. Again, if yours is named differently, make sure to use your function name here. And I've also added a name for this URL as well, calling it rooms. If you didn't name your URL, add the name right now because we're going to use that in a moment. Now to make this work, make sure to also import your view function. Okay, so that's all three of our components, a template, a view, and the URL mapping. Let's test this. Go into the URL rooms. We now see a list of all our rooms. Good, now finally, I want to make a link from here, the home page, to our new rooms page. If you like, you can try your hand at this as well. Just pause the video. So here's what I do. In the welcome template, which is in the website app, I add this line. So this creates a link with the url tag, which references the name of my URL mapping, rooms. And now, we have a link on the home page, and clicking it shows us the new room list.

Best Practice for Urls and Apps
Let's talk a bit more about URL mappings. You see, currently we are not following the best practice for mapping our URLs to views. What we're going to do is to add a urls.py inside our meetings app and change the main urls.py so that it includes the app's URL mappings and adds a prefix. That sounds kind of abstract, so let's see how that actually looks. Usually an app will contain multiple views, and most of the time you will want to put all those views under the same prefix. What I mean with that is the following, I have a couple of different pages in my meetings app, my meeting detail page and the rooms list, and soon I will add another page as well. Now a very common thing to do is to make all the URLs for all pages in the same app to start with the same prefix, let's say meeting/detail, meeting/rooms, and so on. The best practice to handle this is as follows, we create a new file called urls.py inside our app, and let me copy/paste some code in here. So now my meetings app has its own urls.py, and it looks like this. I start by importing the path function, and I import the views function from the app itself as well. Then I create a new variable called urlpatterns, which, just like in the urls.py we saw before, is a list of URL mappings. So in here, I have URL mappings for all the views inside my app. Now to explain how this works, let me also show the urls.py from the meeting_planner folder. So, this is my project‑wide urls.py, and here are the old URL mappings for the admin and our welcome page. And down here are the mappings for the views in my meetings app, the detail page and the rooms_list page. And I'm going to remove those and replace them with a new line. So here, instead of mapping a single view, instead I'm including the URLs for my meetings app, and the includes method will look in that module and find the urlpatterns list there. Interestingly, in this case, we pass the name of our URLs module, meetings.urls, as a string. So, we don't need this import statement anymore because we don't need to import the views from our meetings app anymore. Also, I have to import the include method. So to explain again exactly what this line does, is it includes the urlpatterns on the right here from meetings/urls.py in the project‑wide urls.py with the prefix meetings. So the actual mappings we now have is meetings/rooms and meetings/, followed by a number ID. So what will happen when I open my browser and go to meeting/1 is that this first argument of the call to URL here will match the first part of the URL, meetings/. Django chops that off of the URL, so we're then left with just a number 1, and the include causes it to look in my meetings urls.py, and then we find a match for the remaining number, 1. So now reloading the home page and going to the Rooms list, you see that the rooms list is now hosted under meeting/rooms, but the links still work. So what we've done is to create a urls.py in the meetings app so that the meetings app can define its own URL mappings. All those mappings will be included under the prefix meeting/ because we're including them here in this line in the project‑wide urls.py.

Review
When you configure a URL for your view, you can add a third argument name. In this example, the name is detail. We do this so we can refer to our URLs by name like here in an HTML link. I'm using the URL tag to refer to the meeting detail page by its name. I can also add arguments for the view function, so here I'm passing the ID of the meeting to the view function as well. To understand why we do this, imagine a project with 100 pages with links to the meeting detail page. Now if I need to change my URL mappings, that's not a problem, I simply change the URL mapping and all my links will keep working. This way, I make my code more maintainable. Now don't forget the quotes around the view name in the URL tag because if you forget them, it won't work. And there is another piece of template syntax we've seen as well. If we use curly braces and percent signs, we can use so‑called template tags. The example we've seen is the for tag which works just like a Python for loop. So here, I'm looping over meetings, which is a variable from the template context, and the HTML that's between the for tag and the endfor tag will be repeated for every meeting in meetings. Then we used the double curly braces to print the ID for each meeting. If you have an app with its own views, the best practice is to also give it its own URL configuration inside a file called urls.py in the app folder. Generally speaking, this file is not that different from the urls.py we've seen before. We import the path function and the views we want to map, and then we create the variable called urlpatterns, which is a list of calls to the path function. So then, in the project‑wide urls.py, we want to use the URL config from the app, and to do that, we have to start importing not just a path method, but the include method as well. Next, again, we have a URL patterns variable containing a list of calls to path and here we see a different use of the path function. Again, the first argument is a URL, but the second argument is now a call to includes, which takes a string argument, and that's the name of the module that contains the URL config. So meetings.urls refers to the file urls.py in the meetings app. This will look up the URL patterns list defined in that file, and all URL mappings in that list will be included in the project‑wide URL mapping with the first arguments that we give here as a prefix. So all URLs from meetings.urls will, in this case, start with meetings/. In this module, we've learned a lot about URLs. We saw how to do link building, generating URLs in templates using the names we give to our URLs. We also saw how to reorganize our URL structure to give apps their own URL configuration. Along the way, we learned how to make a for loop in a template. I hope to see you in the next module about styling and template inheritance.

Templates, Styling, and Static Content
Adding Styling with CSS
Hi. I'm Reindert‑Jan Ekker, and in this module, we will learn how to add styling to our site using template inheritance and how to use static content. What I want to do in this module is to apply some styling to our site to make it look a bit nicer. Now I'll admit I'm not very good at making things pretty, but I can at least explain the technologies that you would use for that. The most important one is a language called CSS and we'll not just write from CSS styles, we'll see how to create a simple file with some styles and apply that to the whole site at once using a technique called template inheritance. One side effect of this will be that it also makes our HTML a bit nicer and cleaner. So let's get coding. I'll start by creating a small CSS stylesheet and applying that to a single HTML file. Next, we'll use template inheritance to apply the styles to the whole site and we'll restructure our HTML code to be a bit cleaner in the process. I'm going to add some CSS to our projects. CSS, like HTML, is a thing for the front end, and what I mean by that is that CSS files are sent to the browser and that the browser reach them. HTML defines the contents to show and CSS defines how to style it, so it's about colors and fonts and layouts. So you might think that CSS files go in the templates folder with the HTML templates, but they don't. We make a new folder here in the website app called static, and in there, again, a website folder. So the structure here is similar to templates. Remember in templates, we also have a website folder within there, the actual template, and same goes for static. We have static, and in there, we have a folder with the name of our app. So in there, I create a new text file with the name style.css. And here is a little CSS I wrote. For those of you not familiar with CSS, this is how it works. We have a selector, here its body, and a list of CSS rules applied to that selector and this may set it to everything in the body tag in my HTML page, which is just about everything on the page, we will apply the rule that we want to use a sans‑serif font, make the text color cornflowerblue, and we set a background‑color as well. So let's see how we can actually apply this CSS to our site. Let's go to the welcome template for a moment. What I can do to apply our styles to this page is add a link element to the head like this. Note that this has to be inside the head tag, if you put it anywhere else, it won't work. So adding this will cause the stylesheet to be loaded and the CSS styles to be applied to the page. Now, if I go to the Welcome page and reload, we see nothing changes and that's because sometimes when you do this, you'll need to restart your Django server, so let's do that. I stopped the server and start it again, and now going back to the Welcome page and reloading, we indeed see that the color rules have now been applied. The color has not been applied to the links, but that's a CSS issue, and this course is not really about CSS, but about Django. By adding more rules to your CSS file, you can make this page just look wonderful, but that's not what we're here for. I just want to show you that we can actually do this. By the way, let's make our code a little bit better. At the moment, I've hardcoded the link to our stylesheets, but we know from the previous module that that's a bad idea because it's much better to generate these kinds of URLs. Now with the links, we used a URL tag, but for static content, there is a special tag and it's called static. So this will look up the file website/style.css in my static folder and generate the correct URL. Now to enable this to work, we also need another tag, which needs to be at the top of the file. So here, I'm saying, load static between percent signs and curly braces, and this enables the use of the static tag. Now taking one more look at my CSS file, this is called static content because it doesn't change. We send this exact same file to the browser every time. There are no template placeholders or things like that in here. This file is served as it is and that's why it's called static content and it's separate from templates which dynamically generate different content every time. And the reason we use a static tag here is that it's very well possible that when our application grows, at some point, we want to change the way we host all our static content. Using this tag, we won't have to change our templates when that happens, we will just configure Django so that it will generate the correct URLs for where our static content actually will be hosted. And in that way it's very similar to using the URL tags for links because it makes your templates more maintainable.

Adding an Image
Just to show you we can use static content for more than just CSS, I've put an image in the static folder here called calendar.png. If you want to work along, you can put any image you like in there, doesn't matter if it's a gif, or a jpeg, png, etc. And then in my HTML I can add the following line, img src followed by the static tag, and in there I say website/calendar.png. Make sure to use single quotes around the name of your static file. So, this will generate the URL for my image, and note the quotes around the static block. Those are part of the HTML, not of the static block itself. And I also added width is 100px here to make the image scale nicely, otherwise, you will have a huge icon on your page. Now, refreshing the welcome page, we see that the image has now been included in the page. So you can serve images as static content, as well as CSS, and actually any kind of file you'd like to host in your project. In many projects, you will see JavaScript files in a static folder, but it might also contain JSON or even sound or video. Now, I don't really like the way this looks, so I'm going to remove the image tag from my HTML, but I just wanted to show you that we can do this.

Template Inheritance
Now if I go to another page, we see that the CSS is not actually applied here because there's no link to the stylesheet in the template for this page. So the obvious solution would be to copy/paste the code that loads the stylesheet from the welcome template into every other template. Right now we only have a couple of templates, but in a larger project, you will have dozens or more. So repeating the same link to the stylesheet everywhere is tedious, and if something changes, you will have to go over every template to duplicate the results everywhere. But there's a better way. I'm going to use template inheritance. First, let me create a new template, which I call base.html. I'm putting this directly in the templates folder here in the website app. The reason for that is that it is a template, but I will use it from my other apps as well, so I'm not grouping it inside the website folder there. So creating an HTML file, calling it base.html. This is my base template, and it defines the base structure for our other templates. All the code that is repeated in every template over and over, I can now just put in here. So you see, there's a DOCTYPE, an html tag, a head, and the body tag, all these elements that come back in every page. There's also the load static tag at the top and the link to our stylesheet. Now there's also a new template structure called a block, of which I've defined two, a block called title and a block called content. You can give these blocks any name you like. These blocks mark the parts of the HTML that can be filled in by the templates that inherit from this template, the children. Let's see how that looks. I'm going to start with the welcome template. What I'm going to do is to remove the whole header, including the body tag, and replace it with this, extends "base.html", and this tells Django that we want base.html to be the parent template of this template. Everything that used to be inside the body tag, we now surround with a block content, and we replace the closing tags at the end of the page with an end block. So now we have a page that says we extend from base.html, and here's the code that goes inside the content block. So looking at base.html again, the resulting HTML will start with the html header, start a body tag, and then this block declaration will be filled in with the content from the welcome template. After that, we close the body and html tags. Now we have a second block called title. Let's fill that in as well, and this will make sure that the browser tab for this page will say Welcome. So reloading the welcome page, we see that the result is the same. So the welcome page is still generated correctly, even though we've now broken it down into a parent and a child template. We can repeat the same procedure for all other pages, but I've already done that, so let's see. Here are the templates for my meeting pages, and again, you see the same structure, an extend statement, a title block, and the content block. Now, in my opinion, you can really say that the HTML gets cleaner and simpler by using inheritance. All the ugly declarations at the top of the HTML have moved to the base template, and we're only left with the parts that are specific for this page. Looking at the rooms_list, it's the same thing one more time. Now, if we revisit our site and click a meeting, we see that although the content of each page has stayed the same, we now have the styling applied to every page. The same is true for the Rooms list. Because we use inheritance, we can apply styling to the entire site at once with this one tag here.

Review
So we've seen that you can do template inheritance with Django by starting your template with an extends statement. In the example, we extend from a template called base.html, so that will be the parents template. All HTML in that template will be included in this template, but we can use blocks to fill in parts of the HTML from the parent with content specific to this page. These blocks have to be defined in the parent template. So if the parent template defines a block title, I can use a block title in this page and replace that part of the parent template with my content. We've also seen how to link to a stylesheet from HTML with the link tag. Now my stylesheet is served as a static file. So as the href attribute, I could use a static URL like static/style.css. But the preferred way is to use a static tag, which generates the URL when you give it the name of the static file. This allows us to use static files in such a way that when my setup changes and I want to host my static files another way than simply from the static folder, we won't have to change our templates. So, we've learned about styling in CSS and how to apply that styling to our HTML. We also saw that to apply our style to the whole site at once, we can use template inheritance. A nice side effect of this is that this also makes our HTML cleaner. Good. That's our module about styling and inheritance. Let's go on with our final module about web forms for creating meetings.

Adding User Interaction with ModelForms
A Template with a ModelForm
Welcome. I'm Reindert_Jan Ekker, and in this final module of this course, we'll see how to add forms to our application to enable user input. I would like to enable our users to add meetings themselves, and we can do so by adding forms to our application. On the template side of things, we do so by implementing an HTML form, but we don't write the code for that ourselves. Instead, we let Django generate it by using a so‑called ModelForm. In the corresponding view function, we'll also have to add some code. Specifically, we'll have to process and validate the user input, and if everything is okay, we want to create a new meeting object and save it to the database. And once that's done, we will learn how to redirect the user to another page to show that the operation was successful. Finally, I will talk briefly about forms, validation, and security. Let's start by adding a page for adding new meetings to our application. I will start by creating a template for a web form that the user can fill in using a ModelForm object, and then we'll write the view functionality to process the user input, save the new meeting, and redirect the user to another page. I'm going to create a new view function called new, and all it does is render a template called new.html. The next step is, of course, to add the corresponding template, new.html, and this goes in the templates folder inside the meetings app and inside the meeting folder in there. The structure here is familiar. We start by extending from the base template, and then we have a title block that says New Meeting followed by a content block. Inside the content block, we see a header, Plan a new meeting, and a form tag. Now this is something new. The form tag by itself does nothing, but one way to think of it is that it creates a grouping of tags. The text inside it will together create a form. Now you could write your own HTML here to create form inputs like a text field for a meeting description, an input for a starting time, and another one to pick the room, etc. But the nice thing in Django is that Django can generate the HTML for this form based on our model class. And that's why I have this table tag here and the curly braces saying {{ form}}. This means that the template will need a form variable passed from the view. So let's go back to our view, and here I'll start by adding an import statement, from django.forms import modelform_factory. And right above the definition of the new view, I'm going to call this function we just imported like this. What's happening here is slightly advanced, so let me explain. The modelform_factory method can generate a new class for us called a ModelForm, and the ModelForm can help us create and process HTML forms. We tell the function to generate a ModelForm class based on our Meeting class by passing our Meeting class as the first argument. I also tell it that I want to see all the fields of my meeting model in the HTML form by saying exclude is the empty list. After this function call, the value of MeetingForm will be the newly‑generated ModelForm class. So MeetingForm is a class, not a regular object, and that's also why I'm writing MeetingForm here with capital letters to show that it's a class. Now because this is a class, we can use it in the view function by saying form is MeetingForm, and this will create a new form object that is an instance of the MeetingForm class we just created. So form here is a modelform object for our meetings. I then pass this object to the template by adding this dictionary to our call to render, {"form": form}. Of course, we shouldn't forget to add a URL mapping, so let's go to urls.py in the meetings app. So this is where I've already mapped the other views for our meetings, and here I add a new line mapping our new function to the URL new and giving it the name new as well. And now we can visit the new page in the browser. So the URL for our new view is meetings/new. And here we see a form for creating a new meeting. All the inputs here have been generated by the modelform object based on our meetings model. So let's see those side by side. So what we can see here is that Django tries to generate an appropriate input field for each field in your model. For example, the title field is a character field, and for that, Django generates a text field. The duration is an integer field, and for that, we also get a text field, but it has a number picker with these two little buttons here. The room is a ForeignKey, and Django generates a drop‑down for us, which even shows the existing rooms in the database. Now some fields are a bit too complex for Django to generate beautiful inputs out of the box, for example, date and time are just text fields, but you can customize this, and I'm going to get back to that.

Submitting the Form
Now this is what we have right now. All these inputs here have been generated by this single line where we ask our modelform object to generate HTML inputs for our model class. But we're missing one important thing. You see, the form we have doesn't do anything. It will allow the user to fill in these fields, but not to submit the form and send it to the server. To do that, we have to add a submit button. Now when you add this button, make sure that you add it inside the form. And let me reload the page here. There's the submit button. Now when the user clicks this button, this will cause the entire form to be submitted. It will send everything the user typed in to the server. So let's try that out. I'm going to fill in the form. And as you can see, unfortunately, we need to fill in the date as a string. So here I have to say 2020‑03‑01 for the 1st of March. And I'm just going to keep the Start time and Duration, and let's pick a Room. And now I'm going to submit it by clicking the Create button. Now we didn't write any code to handle the form on the server yet, but let's just look at what happens here. The form gets sent to the same URL that we were already looking at, and you can see that the browser adds a question mark, and then it adds the user input in the form of key value pairs. And you see the name of each form, title, date, etc., etc., and then an equals sign and the data that the user filled in. But actually, this is not the usual way you want to send form data to the server. In most cases, we prefer to send the data back using a different kind of HTTP message called a POST, and we can at this is an argument to the form tag. So here I'm saying, method ="post". So now, here I am back in my form. Now first, I have to refresh this to make sure that the browser has seen the new method is post in the form tag. So let me just remove all of this from the URL, and I'm pressing Enter to reload the page, and let's fill in the form again, and submitting. And now we get an error, CSRF verification failed. This is because Django protects us from a class of a text called CSRF, or cross‑site request forgery. To make our form work, we need to add another line of code to the template, {% csrf token %} in curly braces and percent signs. It's important that you add this inside the form tag as well. Now what this does is it inserts of a piece of code into your HTML form that allows Django to check that the data submitted into the form is not coming from a csrf tag. I'm not going to explain this exactly, but you should at least know that you need this tag in all your Django forms. Here in the browser, I'm going to press back, and I'm going to resubmit the form. And we now see that the error has disappeared. Now the next step is to actually process the user input, and for that, we need to take another look at the view function.

Understanding the Program Flow for Processing a Form
Whenever you have a form in a web application, there are three basic steps. The first we've already seen. We show the form, which is a set of HTML imports, which are generated by a ModelForm class based on our model class. When we visit the page that contains the form, that's a regular page view, which means that the browser sends an HTTP GET request. GET requests are the most common type of HTTP requests, and the browser sends those when you visit a page by clicking a link, for example. So the user clicks on the link to create a new meeting, the browser sends a GET request to our new meeting URL. This calls the view, and it creates a ModelForm instance and sends back the HTML for our form, and we get to see the page with the form. Then the user fills out the form and clicks Submit. And that's the next step. Most of the time, we will send the user input back with a POST request. So now the view will receive a POST request containing the data the user has typed into the form. We need to validate it to see that all fields are filled in correctly, and based on the result of that validation, we either show the form again with errors like, This field cannot be empty or This field has to be a number, etc., or if the form has been filled in correctly, we process the data, for example, saving the data to the database. And then we redirect to another page that shows a success message to the user.

Processing User Input
Inside the view method, I can now add an if statement to test for the HTTP method of the current request, if request.method == POST. Now if the request method is POST, this means that the user has clicked submit and that we can process the user input. Now before doing so, let's also add an else clause. If we end up in the else clause, this means that the request method has to be get, and in that case, the user has not submitted the form yet. In other words, a get request means that the user simply wants to retrieve the form so that he can see it and fill it in. So in that case, we simply render the templates. So what do we do when the method is POST? Well, let's start by retrieving the data that the user typed in. There's an attribute of the request called request.POST and this contains the data that the user filled in. Our goal is to create a new meeting object from that data and store it in the database, and this is another thing that the ModelForm class can help us with. I'm going to say form is MeetingForm and then pass this request.POST, and this will create another MeetingForm object, but this one uses the data that the user filled into the form. Next I say, if form.is_valid, which asks the ModelForm whether the things that the user filled in are actually valid data. This is a very important step, it checks whether all necessary fields are filled in, whether they contain valid data like an actual number for an interview field or a valid date for a date field, and you should never forget to validate your input before you save it into the database. Not just because you might get database errors, but also because of security. Now in case the form has been correctly filled in, we call form.save, which creates a meeting instance for us and saves it into the database. So after this call, there should be a new row in the database with a new meeting. Next I say return redirect("welcome") and instead of rendering an HTML template here, the redirect function will send a special return call to the browser that tells it to redirect to a different page. I'm passing the name of a view here, welcome, and Django will sense the browser, the URL of my welcome page, and tell it to go there. So after successfully submitting the form and inserting a meeting into the database, the user will see the welcome page with the list of meetings and the new meeting should show up there, and it will be a confirmation to the user that everything went well. But in case the form is not valid, I want something else. Now, please pay attention here. I'm going to de‑indent the last line of the function. So what happens here is that this line gets executed in two cases, either the request method was not POST and we created an empty meeting form and are showing that to the user or the user already submitted the form, so we have a POST, but the input was not valid, and in that case we also end up here. But in that case, the form variable holds the form with the data that the user filled in, so we can show that again, and actually, the is_valid method above will have added errors for invalid fields. Now before I show you how that looks, I'm going to have to import the redirect method. So when I go to /meetings/new, this will be a get request and we see an empty form, and when we fill it in, now I'm going to use an invalid date here to trigger an error, the 30th of February. Now when I will click submit, this will be a POST request and the form.is_valid method will be called and that will detect that the date is not valid. So we will not save anything in the database, but instead we will jump to the last line in the function and rerender the template, but this time Django shows us the validation errors in our input. So here it tells me that my date was invalid. So let's set a real date Instead, let's take the 29th because this is a leap year so that works, and now form.is_valid is true, the new meeting gets created and saved in the database and we get to redirect it to the homepage, and on the homepage we now see our meeting in the lists.

A Note About Validation and Security
Now I want to make a point about the validation of the form. Let's try to leave the title field empty and submit the form. Now in this case, I get a warning that looks different than the validation error we got from Django a moment ago. And that is because this validation is done by the browser, and it won't even let me submit the form. So if you would check the Django logs, you wouldn't see a POST request coming in right now. So here the browser is validating these fields, and it prevents me from actually submitting the form. And the message you see here will look differently depending on the browser you use. So browsers can actually check your input, but they cannot check everything. So, for example, this browser I have here, Firefox, will not check whether the date I fill in is correct. So suppose I do feel in a title and I select a room, but let's type in some nonsense for the date. And in this case, I can submit the form, and the actual validation of the input is done by our Python code. And that's why, in this case, we see an error from Django. Now because this behavior varies between browsers, so not all browsers will validate your fields in the same way, and because it's actually possible to submit a form like this without using a browser, so an attacker can submit any form data they like, that means that you should never, ever trust the validation from your browser. And you should always make sure to validate your user input in your Python code on the server. If you don't do this, your code can never be secure.

Customizing Form Fields and Validation
As a final demo, I just want to show you that we can actually make our forms behave a little better. Here, I've added the file called forms.py, and in here, I've created my own ModelForm class. I don't want to go too deeply into this because I just want to show you that you can do these things, but actually going into details is a little bit beyond this Getting Started course. I'm specifying that we need ModelForm for the Meeting class and that we want all fields in the HTML form. But here, I'm also doing some more advanced things. I'm setting widgets for some of my fields and this is a way to control exactly what kind of HTML input Django will show in the form. Here, I'm setting date and time as types for my date and time fields, as well as a minimum and maximum for the duration fields. Also, I've written a custom validation function. Again, I'm not going to go into the details, but I wanted to show you that we can do this. Here, I'm checking that the date the user filled in is not before today, so it's not in the past. Now in views.py, I'm now importing this new Meetingform class, instead of calling the ModelForm factory methods. The rest of the code is exactly the same, it's just using my own ModelForm class now, instead of the generated one. So now if I refresh my Form page, one of the things we get is a nice date picker for the date. Now, how this actually looks depends on your browser, but most modern browsers support this. The time field, unfortunately, is still a bit basic. So this just shows you that you can actually customize the exact inputs that you can show on the form. Now, if we pick a date in the past and submit the form, this will get validated by my own custom validation code and we get this error that I wrote myself. Meetings cannot be in the past. So that's just to show you that we've only seen the tip of the iceberg. Django has a huge number of features and gives you lots of control over all aspects of your application. In this course, we really were just getting started.

Review
We started by creating a template to show a form. There are several things that you need to do for this to work. If you leave any of those out, your form won't function properly. First, we need an HTML form tag that tells the browser how to send the form data to the server. We tell it that the method is post. Then, inside the form tag, we display the form itself by using the form object inside the double curly braces, which will generate input for all form fields. And then there's the csrf token. If you don't include this line in your form, Django will not accept the post request when you submit the form. This is for security purposes, and it's just something you will need to do for every form. Finally, you need to provide a submit button so that the user can actually submit the form. To make this work, you need to provide a form object to show in the template. As a preparation, we call ModelForm factory to create a model form class based on our meeting model class. This newly generated class I call MeetingForm. Then I write a view function. I create a new MeetingForm instance, and then I call render, passing the name of the template and the form objects. But we want our view method to be able to handle the form submits, and to do that, we need to add a little logic. A basic pattern you see in a lot of Django code is this. We start by checking if the current request is a post request. If it is, the user has filled in the form and posted it, and that means we can validate the input and either process it by, let's say, saving something in the database and redirect to a success page, or if the validation gives an error, we can show those errors to the user. But if it's not a post request, that means it's a get request. In other words, the browser asks for empty form to display to the user. With form validation, we mean checking the user input to see if it's acceptable. If the user forgot to fill in a required field or filled in some value, that's not valid, we show an error message. We start by creating a form instance, but in this case, we pass it the data that was posted. So the form fields now contain the data that the user put into the form. Next, we can call form.is_valid to see if the user input is okay. If it is, we call form.save. We shall save the input from the form as a model instance, and then call redirect to another page that shows that the action was successful. If the form isn't valid, we render the template again, and the form we show in the template now contains the data from the user, as well as the validation errors. So the user will be presented with his own input, as well as the error messages that tell him which fields should be corrected. And there we are. This was the final module of this course, and we've learned how to add a web form to our application that enables the user to add meetings. Creating such a web form takes several steps. We started by creating a template that shows the HTML form, and the actual HTML code for the inputs is generated by a model form class that we generate based upon our model class. Then we wrote a view function that validates the input, and if the user input is okay, we create a new meeting object and save it to the database, and then we redirect back to the home page. We also had a short moment to talk about forms and security. So that's all for this Django: Getting Started course. Thank you for watching. I hope you enjoyed it, and I wish you happy coding with Django. This was Reindert‑Jan Ekker for Pluralsight.

Course author
Author: Reindert-Jan Ekker	
Reindert-Jan Ekker
After years of working in software development, Reindert-Jan Ekker switched to teaching programmers in 2010 and never looked back. He authors Pluralsight courses and teaches classes about Python,...

Course info
Level	Beginner
Duration	2h 34m
Updated	4 Mar 2020